// Code generated by tygo. DO NOT EDIT.

//////////
// source: context.go

/**
 * StreamEvent represents a real-time event sent to the client
 */
export interface StreamEvent {
  event: string; // e.g. "token_stream", "node_state_change", "error"
  timestamp: string;
  node_id?: string;
  data?: { [key: string]: any};
}
/**
 * WorkflowContext handles state and data flow during execution
 */
export interface WorkflowContext {
  SessionID: string;
}

//////////
// source: cost.go

export interface CostEstimate {
  total_cost_usd: number /* float64 */;
  total_tokens: number /* int */;
  node_breakdown: { [key: string]: NodeCostEstimate};
  agent_breakdown: { [key: string]: number /* float64 */};
}
export interface NodeCostEstimate {
  cost_usd: number /* float64 */;
  tokens: number /* int */;
}

//////////
// source: engine.go

/**
 * Engine orchestrates the workflow execution
 */
export interface Engine {
  Graph?: GraphDefinition;
  Status: { [key: string]: NodeStatus};
  /**
   * NodeFactory creates processors for graph nodes
   */
  NodeFactory: NodeFactory;
  StreamChannel: any;
  /**
   * Public Mutex for state access
   */
  Mu: any /* sync.RWMutex */;
  /**
   * Middleware hooks
   */
  Middlewares: Middleware[];
  Session?: Session; // Reference to the session state
  MergeStrategy: MergeStrategy; // Pluggable merge strategy
}

//////////
// source: factory.go

/**
 * ConditionalRouter extends NodeProcessor for dynamic routing.
 * Nodes that implement this interface can decide which next nodes to execute
 * based on their execution output.
 */
export type ConditionalRouter = any;
/**
 * FactoryDeps holds dependencies injected into nodes during creation.
 */
export interface FactoryDeps {
  Session?: Session;
}
/**
 * NodeFactory defines the interface for creating node processors.
 * Applications should implement this to provide specific node implementations.
 */
export type NodeFactory = any;
/**
 * DefaultNodeFactory is a base implementation of NodeFactory.
 * It can be embedded in application-specific factories or used for testing.
 */
export interface DefaultNodeFactory {
}

//////////
// source: file_repository.go

/**
 * FileEntity represents a versioned file in the Virtual File System.
 */
export interface FileEntity {
  file_uuid: string;
  session_uuid: string;
  path: string;
  version: number /* int */;
  content: string;
  author: string;
  reason: string;
  created_at: string;
}
/**
 * SessionFileRepository defines the interface for VFS persistence.
 */
export type SessionFileRepository = any;

//////////
// source: merge.go

/**
 * MergeStrategy defines how to merge outputs from multiple upstream nodes
 * when a node has in-degree > 1 (e.g., after parallel branches converge).
 * This is a framework-level interface - implementations can be application-specific.
 */
export type MergeStrategy = any;
/**
 * DefaultMergeStrategy is the basic merge strategy that:
 * 1. Preserves each branch's full output keyed by "branch_N"
 * 2. Passes through the first occurrence of any field (first-come-first-served)
 */
export interface DefaultMergeStrategy {
}

//////////
// source: passthrough.go

/**
 * PassthroughConfig 定义透传配置。
 * 这是一个通用结构，不包含任何业务字段名。
 */
export interface PassthroughConfig {
  /**
   * Keys 需要从 input 透传到 output 的字段名列表
   */
  Keys: string[];
}
/**
 * PromptSection defines a section in the user prompt constructed from input.
 */
export interface PromptSection {
  Key: string;
  Label: string;
}

//////////
// source: processor.go

/**
 * NodeProcessor defines the interface that all node types must implement
 */
export type NodeProcessor = any;

//////////
// source: repository.go

/**
 * WorkflowEntity represents the persistent storage for a workflow.
 */
export interface WorkflowEntity {
  workflow_uuid: string;
  group_uuid: string;
  name: string;
  graph_definition: GraphDefinition;
  created_at: string;
  updated_at: string;
}
/**
 * Repository defines the interface for workflow persistence.
 */
export type Repository = any;

//////////
// source: session.go

export type SessionStatus = string;
export const SessionPending: SessionStatus = "pending";
export const SessionRunning: SessionStatus = "running";
export const SessionPaused: SessionStatus = "paused";
export const SessionCompleted: SessionStatus = "completed";
export const SessionFailed: SessionStatus = "failed";
export const SessionCancelled: SessionStatus = "cancelled";
/**
 * Session represents a single execution instance of a workflow
 */
export interface Session {
  session_uuid: string;
  Graph?: GraphDefinition;
  Status: SessionStatus;
  StartTime: string;
  EndTime: string;
  Inputs: { [key: string]: any};
  Outputs: { [key: string]: any};
  Error: any;
  signal_channels?: { [key: string]: any};
  context_data: { [key: string]: any}; // Runtime context for Loop variables, etc.
}

//////////
// source: session_repository.go

/**
 * SessionEntity represents the persistent state of a session.
 */
export interface SessionEntity {
  session_uuid: string;
  group_uuid: string;
  workflow_uuid: string;
  status: SessionStatus;
  proposal: { [key: string]: any};
  node_statuses?: { [key: string]: NodeStatus};
  started_at?: string;
  ended_at?: string;
}
/**
 * SessionRepository defines the interface for session persistence.
 */
export type SessionRepository = any;

//////////
// source: template.go

export type TemplateCategory = string;
export const TemplateCategoryCodeReview: TemplateCategory = "code_review";
export const TemplateCategoryBusinessPlan: TemplateCategory = "business_plan";
export const TemplateCategoryQuickDecision: TemplateCategory = "quick_decision";
export const TemplateCategoryCustom: TemplateCategory = "custom";
export const TemplateCategoryOther: TemplateCategory = "other";
export interface Template {
  template_uuid: string;
  name: string;
  description: string;
  category: TemplateCategory;
  is_system: boolean;
  graph: GraphDefinition;
  created_at: string;
  updated_at: string;
}
export type TemplateRepository = any;

//////////
// source: types.go

/**
 * NodeStatus defines the execution state of a node
 */
export type NodeStatus = string;
export const StatusPending: NodeStatus = "pending";
export const StatusRunning: NodeStatus = "running";
export const StatusCompleted: NodeStatus = "completed";
export const StatusFailed: NodeStatus = "failed";
export const StatusSkipped: NodeStatus = "skipped";
export const StatusSuspended: NodeStatus = "suspended";
/**
 * NodeType enum for supported node types
 */
export type NodeType = string;
export const NodeTypeStart: NodeType = "start";
export const NodeTypeEnd: NodeType = "end";
export const NodeTypeAgent: NodeType = "agent";
export const NodeTypeLLM: NodeType = "llm"; // Direct LLM call
export const NodeTypeTool: NodeType = "tool"; // Search, etc.
export const NodeTypeParallel: NodeType = "parallel"; // Logic node: Parallel branch
export const NodeTypeSequence: NodeType = "sequence"; // Logic node: Sequential steps
export const NodeTypeVote: NodeType = "vote"; // Logic node: Vote
export const NodeTypeLoop: NodeType = "loop"; // Logic node: Loop
export const NodeTypeFactCheck: NodeType = "fact_check"; // Logic node: Fact Check
export const NodeTypeHumanReview: NodeType = "human_review"; // Logic node: Human Review
export const NodeTypeMemoryRetrieval: NodeType = "memory_retrieval"; // Logic node: Memory Retrieval
export const NodeTypeContextSynth: NodeType = "context_synth"; // Logic node: Context Synthesizer
/**
 * GraphDefinition represents the static definition of a workflow
 */
export interface GraphDefinition {
  workflow_uuid: string;
  name: string;
  description: string;
  nodes: { [key: string]: Node | undefined};
  start_node_id: string;
}
/**
 * Node represents a single step in the workflow
 */
export interface Node {
  node_id: string;
  type: NodeType;
  name: string;
  next_ids?: string[]; // Adjacency list for next steps
  properties: { [key: string]: any}; // Node-specific config (e.g. Prompt, Model)
}
/**
 * Middleware allows intercepting node execution for safety and observability
 */
export type Middleware = any;
