# 贡献流程

<cite>
**本文档引用的文件**  
- [README.md](file://README.md)
- [GEMINI.md](file://GEMINI.md)
- [Makefile](file://Makefile)
- [docs/development_plan.md](file://docs/development_plan.md)
- [docs/tdd/08_adr.md](file://docs/tdd/08_adr.md)
- [frontend/eslint.config.js](file://frontend/eslint.config.js)
- [docs/specs/sprint6/SPEC-609-architecture-fixes.md](file://docs/specs/sprint6/SPEC-609-architecture-fixes.md)
- [docs/specs/sprint6/SPEC-606-documentation.md](file://docs/specs/sprint6/SPEC-606-documentation.md)
</cite>

## 目录
1. [简介](#简介)
2. [Git分支与提交规范](#git分支与提交规范)
3. [代码风格与格式化](#代码风格与格式化)
4. [架构决策记录（ADR）机制](#架构决策记录（adr）机制)
5. [代码审查检查清单](#代码审查检查清单)
6. [开发流程与质量保障](#开发流程与质量保障)

## 简介
本文档旨在为《理事会》（The Council）项目制定统一的代码贡献规范，确保团队协作的一致性和代码质量。通过明确的分支命名、提交信息格式、代码风格、架构决策流程和审查标准，建立高效、可维护的开发实践。本规范覆盖了从代码提交到合并的完整生命周期，是所有贡献者必须遵循的准则。

## Git分支与提交规范

项目采用基于功能的分支策略，确保开发工作的隔离性和可追溯性。所有代码变更必须通过Pull Request（PR）进行审查和合并。

### 分支命名规则
- **功能开发**: `feat/<功能描述>`，例如 `feat/user-authentication`
- **缺陷修复**: `fix/<问题描述>`，例如 `fix/login-bug`
- **文档更新**: `docs/<主题>`，例如 `docs/contribution-guide`
- **代码重构**: `refactor/<模块>`，例如 `refactor/workflow-engine`
- **预发布版本**: `release/v<版本号>`，例如 `release/v0.15.0`

### 提交信息格式
所有提交信息必须遵循[Conventional Commits](https://conventionalcommits.org)规范，以确保自动生成清晰的变更日志（CHANGELOG）。格式如下：
```
<类型>(<范围>): <简短描述>

<详细描述>

<关联的PR或Issue>
```
- **类型 (type)**: `feat` (新功能), `fix` (缺陷修复), `docs` (文档), `style` (格式), `refactor` (重构), `test` (测试), `chore` (构建/工具)
- **范围 (scope)**: 变更影响的模块，如 `api`, `frontend`, `workflow`, `memory`
- **简短描述**: 一句话概括变更内容，使用现在时，首字母小写，不加句号。
- **详细描述**: 可选，详细说明变更原因和实现方式。
- **关联**: 使用 `Closes #<issue-number>` 或 `Related to #<pr-number>` 关联相关工单。

**示例**:
```
feat(workflow): add memory_retrieval node type

Introduce a new node type for retrieving historical context from the three-tier memory system.
This enables iterative workflows to access previous deliberations.

Closes #607
```

**Section sources**
- [README.md](file://README.md#L290-L312)
- [GEMINI.md](file://GEMINI.md#L14)

## 代码风格与格式化

项目对Go和TypeScript代码有明确的风格要求，通过自动化工具强制执行，确保代码库的一致性。

### Go代码风格
- **格式化**: 使用 `gofmt -s` 进行格式化。`-s` 标志启用简化模式，使代码更简洁。
- **导入**: 使用 `goimports` 自动管理导入语句，按标准库、第三方库、项目内部库分组。
- **命名**: 
  - 变量和函数使用 `snake_case`。
  - JSON序列化字段使用 `snake_case`。
  - 结构体和接口使用 `PascalCase`。
- **错误处理**: 使用 `fmt.Errorf("...: %w")` 包装错误，保留原始错误信息。
- **并发**: 所有可能阻塞的操作必须接受 `context.Context` 参数，以便于取消和超时控制。

### TypeScript代码风格
- **格式化**: 使用 `Prettier` 进行代码格式化，确保统一的代码风格。
- **静态检查**: 使用 `ESLint` 进行代码质量检查，配置文件位于 `frontend/eslint.config.js`。关键规则包括：
  - 禁止使用 `any` 类型，强制类型安全。
  - 严格模式，启用所有推荐规则。
  - 与 `React Hooks` 规则集成，确保Hook的正确使用。
- **命名**: 
  - 变量和函数使用 `camelCase`。
  - React组件使用 `PascalCase`。
  - Props和接口使用 `PascalCase`。
  - JSON序列化字段使用 `camelCase`。

### 自动化执行
项目通过 `Makefile` 提供了便捷的命令来执行格式化和检查：
- `make fmt`: 格式化所有Go代码。
- `make lint`: 运行所有静态检查（Go和前端）。
- `make check`: 运行所有检查，包括 `lint` 和 `test`。

**Section sources**
- [GEMINI.md](file://GEMINI.md#L18-L25)
- [Makefile](file://Makefile#L260-L262)
- [frontend/eslint.config.js](file://frontend/eslint.config.js#L1-L24)

## 架构决策记录（ADR）机制

对于影响核心逻辑或系统架构的重大变更，贡献者必须遵循ADR（Architecture Decision Record）机制，以确保设计的透明性和可追溯性。

### ADR流程
1. **提案**: 在修改核心逻辑前，贡献者应在 `docs/tdd/` 目录下创建一个新的ADR文档，文件名格式为 `ADR-<编号>: <主题>.md`。
2. **内容**: ADR文档必须包含以下部分：
   - **决策**: 明确的决策内容。
   - **状态**: 初始为 `提案中`，经团队讨论后更新为 `已采纳` 或 `已拒绝`。
   - **背景**: 为什么需要这个决策。
   - **候选方案对比**: 列出所有可行的方案，并分析其优劣。
   - **决策理由**: 详细阐述最终选择该方案的原因。
3. **讨论**: 将ADR提案作为Pull Request提交，邀请团队成员进行公开讨论。
4. **采纳**: 经过充分讨论并达成共识后，由项目维护者将状态更新为 `已采纳` 并合并PR。
5. **实施**: 基于已采纳的ADR进行代码实现。

### ADR示例
项目中已有的ADR记录（如 `docs/tdd/08_adr.md`）可作为参考：
- **ADR-001**: 数据库选型 — PostgreSQL + pgvector
- **ADR-002**: 后端框架选型 — Gin
- **ADR-003**: 前后端架构 — React SPA + Go API 分离模式

此机制确保了任何重大变更都有充分的论证和记录，避免了随意修改核心架构的风险。

**Section sources**
- [docs/tdd/08_adr.md](file://docs/tdd/08_adr.md#L1-L108)
- [GEMINI.md](file://GEMINI.md#L14)

## 代码审查检查清单

所有Pull Request在合并前都必须通过代码审查。审查者应使用以下检查清单确保代码质量。

### 性能
- [ ] 是否存在不必要的数据库查询？是否可以使用缓存（Redis）？
- [ ] 对于计算密集型操作，是否考虑了并发和超时？
- [ ] 前端组件是否进行了性能优化（如使用 `React.memo`）？
- [ ] WebSocket消息是否精简，避免传输冗余数据？

### 安全性
- [ ] 是否对所有用户输入进行了验证和清理？
- [ ] 敏感信息（如API密钥）是否通过环境变量注入，且未硬编码？
- [ ] 是否存在潜在的注入攻击风险（SQL注入、XSS）？
- [ ] 权限控制是否到位，确保用户只能访问其有权访问的资源？

### 可测试性
- [ ] 新增的业务逻辑是否包含单元测试？Go代码覆盖率是否达标？
- [ ] 是否为前端组件编写了相应的测试用例？
- [ ] 测试是否覆盖了边界条件和错误处理路径？
- [ ] 是否避免了在测试中使用真实的数据库或LLM服务？

### 文档更新
- [ ] 是否更新了相关的API文档（如 `docs/api/` 下的文件）？
- [ ] 是否更新了用户指南或开发文档（如 `docs/guide/`）？
- [ ] 代码中的注释是否清晰，解释了复杂的逻辑？
- [ ] `README.md` 或 `CHANGELOG.md` 是否反映了本次变更？

**Section sources**
- [GEMINI.md](file://GEMINI.md#L70-L74)
- [docs/specs/sprint6/SPEC-606-documentation.md](file://docs/specs/sprint6/SPEC-606-documentation.md#L1-L187)

## 开发流程与质量保障

项目的开发流程强调质量内建（Quality Built-In），通过自动化工具链确保代码的稳定性和可靠性。

### 开发生命周期
项目使用 `Makefile` 统一管理开发命令，核心流程如下：
1. **启动**: `make start` 一键启动所有服务（数据库、后端、前端）。
2. **构建**: `make build` 编译生产环境的二进制文件和前端包。
3. **测试**: `make test` 运行所有单元测试和集成测试。
4. **检查**: `make check` 执行 `lint` 和 `test`，作为合并前的最终检查。
5. **清理**: `make clean` 停止所有服务并清理构建产物。

### 质量门禁
每个功能规格（SPEC）在标记为“完成”前，必须通过以下质量门禁：
- **代码检查 (Lint)**: 无任何静态检查错误。
- **测试覆盖 (Test)**: 核心模块（如工作流引擎）要求100%单元测试覆盖率。
- **验收标准**: 实现的功能必须满足SPEC文档中定义的所有验收标准。
- **文档更新**: 相关的开发计划和用户文档必须同步更新。

此流程确保了每一次提交都经过了严格的验证，从源头上保证了代码库的健康。

**Section sources**
- [Makefile](file://Makefile#L1-L374)
- [docs/development_plan.md](file://docs/development_plan.md#L1-L155)
- [GEMINI.md](file://GEMINI.md#L14)